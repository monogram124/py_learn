# средний уровень

# СЛОВАРИ - еще один тип коллекций, который позволяет сопоставлять произвольные ключи со значениями, так же как и списки могут быть проиндексированы

ages = {
    "Dave": 24,
    "Mary": 42,
    "John": 58
}
ages["Dave"] # 24
ages["John"] # 58

# функции словарей
# чтобы определить находиться ли ключ в словаре можно использовать in или not in

nums = {
    1: "one",
    2: "two",
    3: "three"
}

names = {
   "Maxim": 14,
   "David": 13,
   "Sergey": 14
}

print(1 in nums) # True
print("three" in nums) # False
print(4 not in nums) # True

# get(), по сути делает то же самое что и индексирование но если не нашел нужный элемент возрващает значение стоящее вторым аргуентом
print(nums.get(4, "not found"))

# КОРТЕЖИ TURPLES ТЮРПЛЫ, очень похожи на списки, но их нельзя изменить

words = ("spam", "eggs", "sausages")
print(words[0]) # если бы я попробовал переназначить значение words[1] = "cheese", это привело бы к ошибке

# так же кортеж можно создать и без использования скобок, просто отделяя запятыми
my_tuple = "one", "two", "three"

# распаковка кортежа, позволяет присвоить каждому элементу в коллецкции переменную
numbers = [1, 2, 3, 4]
a, *b, c = numbers # если переменная со звездочкой то ей будут присвоены значения лиюо до конца лиюо до следующей перменной

# SETS или МНОЖЕСТВА, похожи на списки и словари, но они не упорядочены что значит что не могут быть проиндексированы, так же множества не могут сожержать дубликаты элементов
num_set = {1, 2, 3, 4, 5}
print(3 in nums)

num_set.add(-7) # добавить элемент
num_set.remove(2) # удалить элемент
print(nums) # 1, 3, 4, 5, -7

# повторяющиеся элементы будут автоматически удалены из множества

# множества могут быть объединены использую мат операторы
first = {1, 2, 3}
second = {4, 5, 6}

print(first | second) # склеит два множества {1, 2, 3, 4, 5, 6}
print(first & second) # выводит те элементы которые есть в обоих множествах {}
print(first - second) # выводит те элементы которые есть в первом множестве но нет во втором
print(second - first) # наборот 
print(first ^ second) # ???

# СПИСКОВОЕ ВКЛЮЧЕНИЕ или ГЕНЕРАТОРЫ СПИСКОВ или LIST COMPREHESIONS

# быстрый способ создать список который будет подчиняться опеределенному правилу

a = [i for i in range(10)] # список от нуля до 9
b = [i**2 for i in range(10)] # список квадратов i
c = [i ** 2 for i in range(10) if i**2 % 2 == 0] # так же может создержать условие по которому создаётся список

print(a)

# на данный момент структуры данных которые есть в питоне: строки, целые числа, дробные числа, списки, словарики, кортежи, множества
"""
Когда использовать словарь:
- Когда вам нужна логическая связь между парой ключ:значение.

- Когда вам нужен быстрый поиск данных на основе пользовательского ключа.

- Когда ваши данные постоянно изменяются. Помните, что словари изменчивы.

Когда использовать другие типы:
- Используйте списки, если y вас есть коллекция данных, которая не требует произвольного доступа. Старайтесь выбирать списки,
  когда вам нужна простая, итерируемая коллекция, которая часто изменяется.

- Используйте набор, если вам нужна уникальность элементов. 

- Используйте кортежи, когда ваши данные не могут/не должны изменяться.
"""

# ФУНКЦИИ ВЫСОКОГО ПОРЯДКА
def apply_twice(func, arg):
   return func(func(arg))

def add_five(x):
   return x + 5

print(apply_twice(add_five, 10))

# ФУНКЦИИ так же деляца на функции чистые и нечистые
# ЧИСТАЯ ФУНКЦИЯ - та которая не зависит от внешних параметров а только от своих аргументов и базировано на них с одинковым аргументом вернёт одинаковый ответ
def pure_function(x, y):
  temp = x + 2*y
  return temp / (2*x + y)
# НЕ ЧИСТАЯ ФУНЕЦИЯ - та котороая зависит от внешних факторов
some_list = []

def impure(arg):
  some_list.append(arg)

# чистые функции эффективны чтобы сохрнаить результат в памяти и затем не вычислять его повторно 
# легче рассуждать и тестировать

# уменьншение кол-ва вызова функция - МЕМОРИЗАЦИЯ

# лямбада функции, то же самое как в js, так же называются анонимными, много используются как кол-бек функции или как аргумент для какой то другой функции
# синтаксис:

def my_func(f, arg):
   return f(arg)

my_func(lambda x: 2*x*x, 5)

# лямбада функции не такие мощные как функции обычные и чаще всего вмещают в себя одну строку кода

# map() функция высшего порядка которая в качестве первого аругмента принимает другую функию и применяет её к списку который находится во втором аргуемнте
salaries = [2000, 1800, 3100, 4400, 1500]
# bonus = int(input("int "))

# res = list(map(lambda x: x + bonus, salaries))

# print(res)

# filter() фильтрует список с таким же синтакисиом как и map оставляю только те элементы котороые подходят под условие
nums2 = [16, 2, 6, 3, 15, 6, 3, -25, 44]

result = list(filter(lambda x: x % 2 == 0, nums2))

print(result)

print("="*35 + "ГЕНЕРАТОРЫ")
# ГЕНЕРАТОРЫ, YIELD, функция генератор - та функция которая всегда возвращает объект генератор до пенка, никакие не целые или конечные значения
# генератор ленивый (lazy) - что значит пока мы не попросим (вызовем функцию next или через цикл), то он просто будет возвращать объект генератор а не то что тот выполянет
# функция next() деоает одну иттерацию
# когда генератор перебрал все значение которые может выводит stopIterration 
# суть генератора в том что обычным l = list(range(100000)) обгойтись не возможно, получим MemoryError, генераторы нужны для прохождения по большим массивам данных, и так же можно вызывать либо всё вместе через for либо через next по отдельности

squares = [i ** 2 for i in range(0, 11, 2)] 

def squaresFunc():
   print("Generator working...") # не сработает пока не дать пинка

   for e in range(0, 11, 2):
      yield e ** 2 # yield то же самое что и return только для генераторов, то есть тогда компьютер понимает что ему нужно вернуть именно объект генератор

      # если есть хоть один yield - функция автоматически становится генератором

gen = squaresFunc()

print(gen)
print(next(gen)) # пинать его можно next и можно for, так же for понимает когда ему нужно перестать работать и когда не осталось больше что перебирать и не выводит stopItteration
for e in gen:
   print(e)
# функция генератор создает объект генератор который для просоты можно представлять как лист компрехешон

def pause():
   print("Generator working...")

   while True:
      print(a)
      yield a

a = 10
gen2 = pause()
print(next(gen2))
a = 20
print(next(gen2))

# c 164 по 175 суть в том что генератор сохраняет всё что в нем происходит, тут когда дошли до йилда до он просто встанет на паузу не уничтожится,
# а когда мы измениили переменную он возвразается в свою функцию и делает тот же самый код уже с другим значением

# ДЕКОРАТОРЫ - патерн програмирование, основное предназначение, изменить поведение какой то функции не менняя её код
# функия - полноправный объект
# внутренняя функция может захватывать перменные из внешней

print("="*35 + " ДЕКОРАТОРЫ")

# тут нужно понимать что внутренняя функция имеет доступ к переменным внешней,
# то есть во первых мы спокойно можем создавать функции внутри функций, и внутренние будут иметь доступ к аргументам функции внешних

def example(a): 
   def inner(b):
      print(a+b)

   inner(3)

def logger(func): # это и есть сам декоратор а синтаксический сахар для него и есть @logger
   def wrap(*args): # *args - темка отражает все аргументы функции, то есть когда ты не знаешь точное кол-во аргументов пишешь *args и всё
      print(f"{func.__name__} started")
      res = func(*args)
      print(f"{func.__name__} finished")

      return res
   
   return wrap

# какую бы функцию мы бы там не передали в logger() он всегда вернет нам wrap

@logger # то есть вот эта одна строка она замещает собой присваивание всех переменных, дохождения до wrap и просто выполняет эту операцию logger(summ)(2, 3)
# это команда заменить функцию которая ниже на функцию обертку
def summ(a, b):
   return a + b

print(summ(2, 3))

# function = logger(summ)
# print(function) <function logger.<locals>.wrap at 0x00000250C87DFBA0> самое главное тут что у нас получили доступ к wrap, т. к. мы вернули его из logger
# print(function(2, 3)) функция декоратор просто как бы обертка работает так что мы передаем в основную функцию ту которую декоруем и производим манипуляции

# print(logger(summ)(2, 3)) то же самое просто в одну строку, логгер вернул wrap с функцией sum обертке передаем параметры и он вернул результат

# тут мы присвоили function значение вызова logger(summ) с функцией summ внтури потом в функции wrap внутренней для logger, то есть по факту это wrap потому что мы его возвращаем
# а потом мы просто в wrap передали a и b а он внутри изменил поведение функции написав что раьота начата и работа закончена 
# то есть мы изменили поведение без измениение кода

# предаставить можно как скафандер для человека, человек остаётсяя тем же самым а со скафандрем может выйти в открытый космос

# function = summ
# print(summ)
# print(function)

# *args и **kwargs
print("="*35 + " *ARGS И **KWARGS")

def func(named_arg, *args): # args может передовать произвольное кол-во аргументов, просто потом они будут храниться в кортеже args и жоступ к ним можно получить с помощью индекса
   print(named_arg)
   print(args)

func(1, 2, 3, 4, 5, 6)

# **kwargs (расшифровывается как аргументы ключевых слов), позволяет добавлять именнованные аргументы которые не были определены заранее
# аргументы ключевых слов возвращают словарь где ключ - имя аргумента, а значение - значение аругмента

def my_func(x, y=7, *args, **kwargs):
   print(kwargs)

my_func(2, 3, 4, 5, 6, a=7, b=8) # то есть мы не просто добавляем произвольное кол-во аргументов и потом получаем их в кортеже а у них теперь есть имена и получить доступ можно не только по индексу

# так же важно что аргументы включаемые в **kwargs не включаются в *args


print("="*35 + " ООП")
# ООП - способ решения задач где все и всё объекты и они взаимодействуют между собой
# в питоне всё является объектом
# Классы
# все мыслят объектами, поэтому это удобнее чем то же функциональное програмирование (где используются функции)
# центральное понятие ООП - объект - сущность, объединяющая данные и методы работы с ними (состояние и поведение), состояние - данные, поведение - методы

# класс - новый тип данных, объект его конкретный представитель, как раз таки когда не хватает типов данных и нужно создать структуры данных, классы очень помогают
# то есть создавая класс мы всегда создаем новый тип данных, пример с интом, int - тип данных, числа его представители
class Cat: # разница класса и объекта, класс - чертеж а дом это объект, то есть класс некоторые критерии по которым создается объект
    
    # дандер методы, магические методы, нужны по факту просто для того чтобы более гибко и удобно работать с классами
   def __init__(self, name, age):
      self.name = name # состояние - данные
      self.age = age
       
   def meow(self): # поведение
      print(self) # self - ссылка на объект класса
      print(f"{self.name} says: meowed")

# первый аргумент в методах класса это всегда self, ну как и в js метод та же функция только привязанная к определенному классу

tom = Cat("Tom", 2)
angela = Cat("Angela", 3) # уже другой объект, в другой области памяти, хотя тип данных один

# класс может сравнивать себя но только по ссылке в памяти не по каким то параметрам
print(tom)
print(angela)
print(type(tom)) # то есть у каждого объекта есть свой адрес в памяти и его тип

tom.meow() # аналагично Cat.meow(tom)
print(tom)

# ПОДРОБНЕЕ О ДАНДЕР МЕТОДАХ
# ДАНДЕР МЕТОДЫ - позволяют классам реализовать опеределнные операции, тк до их реалезации классы не умеют делать всего того чему их учат дандер методы(сравнение, инициализация, вывод)

# repr - для програмиста, возврщает строку по которой видно (и можно воссоздать) состояние объекта
# str - для людей, возвращает строку
# eq по умолчанию сравнивает адрес в памяти, в реализации лучше проверять одного ли класса наследники
# lt - меньще 
# gt - больше
# ge - больше или равно
# le - меньше или равно
# bool - для самописных объектов возращает true, для изменения поведения нужно прописать дандер метод __bool__
# len - нужен потому что не умеет пока самописный класс опеределять свою длину, но если определить __len__ то всё будет работать
# call - нужен для того чтобы объект класса можно было вызывать как функцию и он бы что то возващал в нашем случае сумму всего того что лежит в кошельке wallet(), call делает объект вызываемым
# iter - возвращет объект, тот кто реализует - iterable
# dict - вернет объект класса в виде словаря

class Banknote:
   def __init__(self, value: int):
      self.value = value
   
   def __repr__(self): # репр представляет собой объект класса в виде строки, репр - для програмиста, стр - для людей
      return f"Banknote({self.value})"
   
   def __str__(self): # при реализации класса сразу лучше реализовать либо str и repr
      return f"Банкнота номиналом в {self.value} рублей"

   def __eq__(self, other): # eq нужен для того чтобы научить сравнивать объекты
      if other == None or not isinstance(other, Banknote): # хорошая привычка проверять вообще одного ли класса эти объекты наследники, делается это вот таким способом
         return False
      return self.value == other.value

   def __lt__(self, other): # less than, проверка на то меньше ли он,и тут тоже лучше проводить проверку типа, тут не проверяю просто потому что знаю что одного типа 
      return self.value < other.value
   
   def __gt__(self, other): # greater than
      return self.value > other.value
   
   def __ge__(self, other): # greater or equal
      return self.value >= other.value
   
   def __le__(self, other): # less or equal
      return self.value <= other.value
   # все вот эти методы сравнения призваны научить сравнивать любые параметры объектов классов

class Wallet:
   def __init__(self, *banknotes: Banknote):
      self.container = []
      self.container.extend(banknotes)
      self.index = 0

   def __repr__(self):
      return f"Wallet({self.container})"

   def __contains__(self, item):
      return item in self.container
   
   def __bool__(self): # по умолчанию когда мы проверяем наш самописный объект на boolean значение он всегда вернет true
      return len(self.container) > 0 # len работает за констанстное времия O(1), так что можно не бояться его использовать при каких то проверках
   
   def __len__(self):
      return len(self.container)

   # def __call__(self): # 
   #    return f"{sum(e.value for e in self.container)} рублей"

   def __iter__(self):
      return self # возвразаем себя, но это хначит что мы сами дожны быть итератором
   
   def __next__(self):
      if self.index < 0 and self.index  < len(self.container):
         value = self.container[self.index]
         self.index += 1
         return value
      raise StopIteration


   # итератор - набор данных который при вызове метода next возвращает один из своих элементов

banknote = Banknote(50) # init по умолчанию не ждет аргументов, то есть если мы не создали его в нашем классе то не надо даже пытаться туда что то передавать
fifty = Banknote(50)
hundred = Banknote(100)
wallet = Wallet(banknote, fifty, hundred, 10, 5, 2)

print(banknote) # так выводить стр 
print(f"{banknote!r}") # так выводить репр
# у стр и у репр есть встроенные функции str() и repr() они соответственно и вызывают дандер методы которые прежставлены у нас в классе 
# то есть __repr__ и __str__ просто адрес в памяти преобразуют в красивенький вывод
# если нет стр он будет использовать стр

#если в классе не реализованн eq питон думает что это два разных объекта в памяти и они имеют разныве адресва в памяти, и нормально сравнить мы их не можем
print(f"Реализован метод __eq__ {banknote == fifty}") # True, уже с реалезованным методом __eq__, так бы было бы False
print(banknote == hundred) # False, так же с реалезованным __eq__ 

print(f"Реализованны методы сравнения __lt__ __gt__ __ge__ __le__ {fifty > hundred}")
print(f"Реализован метод __contains__ {50 in wallet}")


if wallet: # проверка на то пустой ли кошелек или нет, реалиозвали с помощью дандер метода __bool__
   print(f"Реализован метод __bool__ 1")

print(f"Реализован метод __len__, купюр в кошелке: {len(wallet)}")

# print(f"Реализован метод __call__, вызывая обхект класса получаем сумму всех купюр внтури {wallet()}") ну че то у меня не получилось правильно __call__ написать короче

for money in wallet:
   print(money)

# инкапсуляция - все данные и методы для работы с ними находяться в одном месте, всё собранно в одной капсуле, в классе
# то есть когда у тебя данные разбросаны как в примере ниже то у тебя просто не понятно какие методы и данные долдны работать вместеЭ№
# суть инкапсуляции в том чтобы собрать все данные и все методы в одно место для работы с ними 
kitty = {
   "name": "Kanye",
   "age": 3
} 

def meow():
   print("Meow")

# а вот пример инкапсуляции это как раз наш класс cat представленый выше
# инкапсуляция просто абстрактное понятие для понимания, то есть все меотды и данные компануются в класс и есть дандер методы и обычные методыm те которые по умолчанию как бы и с которыми взаимодействуют

# наследование классов - когда один класс определяется на основе другого

class Geom: # Geom - базовый класс или родительский, при наследовании классов, наследуются все атрибуты и методы родительского класса к дочернему
   name = "Geom"

   def set_coords(self, x1, y1, x2, y2):
      self.x1 = x1
      self.y1 = y1
      self.x2 = x2
      self.y2 = y2
class Line(Geom): # это и есть наследование, Line дочерний класс,
   def draw(self):
      print("рисовую линию")

class Rect(Geom):
   def draw(self):
      print("Рисование прямоугольника")

l = Line() # параметр self базового класса может ссылаться не только на объект этого класса, но и на объект дочернего класса, смотря через что его вызывать, если через дочерние на дочерние и с родительскими соответсвенно
r = Rect()
l.set_coords(1, 1, 2, 2)
r.set_coords(1, 1, 2, 3)

print(l.__dict__)
print(r.__dict__)

# ПОВТОРИТЬ:
# дандер методы и декораторы

# ИЗУЧИТЬ:
# деревья 